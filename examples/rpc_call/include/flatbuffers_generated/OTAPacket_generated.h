// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OTAPACKET_MESSAGING_H_
#define FLATBUFFERS_GENERATED_OTAPACKET_MESSAGING_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
// static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
//               FLATBUFFERS_VERSION_MINOR == 2 &&
//               FLATBUFFERS_VERSION_REVISION == 10,
//              "Non-compatible flatbuffers version included");

namespace Messaging {

struct OTAPacket;
struct OTAPacketBuilder;

struct OTAPacket FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef OTAPacketBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_SEQUENCE_NUMBER = 4,
        VT_LENGTH = 6,
        VT_PAYLOAD = 8
    };
    uint16_t sequence_number() const {
        return GetField<uint16_t>(VT_SEQUENCE_NUMBER, 0);
    }
    uint16_t length() const {
        return GetField<uint16_t>(VT_LENGTH, 0);
    }
    const ::flatbuffers::Vector<uint8_t> *payload() const {
        return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) &&
               VerifyField<uint16_t>(verifier, VT_SEQUENCE_NUMBER, 2) &&
               VerifyField<uint16_t>(verifier, VT_LENGTH, 2) &&
               VerifyOffset(verifier, VT_PAYLOAD) && verifier.VerifyVector(payload()) &&
               verifier.EndTable();
    }
};

struct OTAPacketBuilder {
    typedef OTAPacket Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_sequence_number(uint16_t sequence_number) {
        fbb_.AddElement<uint16_t>(OTAPacket::VT_SEQUENCE_NUMBER, sequence_number, 0);
    }
    void add_length(uint16_t length) {
        fbb_.AddElement<uint16_t>(OTAPacket::VT_LENGTH, length, 0);
    }
    void add_payload(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> payload) {
        fbb_.AddOffset(OTAPacket::VT_PAYLOAD, payload);
    }
    explicit OTAPacketBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<OTAPacket> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<OTAPacket>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<OTAPacket>
CreateOTAPacket(::flatbuffers::FlatBufferBuilder &_fbb, uint16_t sequence_number = 0,
                uint16_t length = 0,
                ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> payload = 0) {
    OTAPacketBuilder builder_(_fbb);
    builder_.add_payload(payload);
    builder_.add_length(length);
    builder_.add_sequence_number(sequence_number);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<OTAPacket>
CreateOTAPacketDirect(::flatbuffers::FlatBufferBuilder &_fbb, uint16_t sequence_number = 0,
                      uint16_t length = 0, const std::vector<uint8_t> *payload = nullptr) {
    auto payload__ = payload ? _fbb.CreateVector<uint8_t>(*payload) : 0;
    return Messaging::CreateOTAPacket(_fbb, sequence_number, length, payload__);
}

inline const Messaging::OTAPacket *GetOTAPacket(const void *buf) {
    return ::flatbuffers::GetRoot<Messaging::OTAPacket>(buf);
}

inline const Messaging::OTAPacket *GetSizePrefixedOTAPacket(const void *buf) {
    return ::flatbuffers::GetSizePrefixedRoot<Messaging::OTAPacket>(buf);
}

inline bool VerifyOTAPacketBuffer(::flatbuffers::Verifier &verifier) {
    return verifier.VerifyBuffer<Messaging::OTAPacket>(nullptr);
}

inline bool VerifySizePrefixedOTAPacketBuffer(::flatbuffers::Verifier &verifier) {
    return verifier.VerifySizePrefixedBuffer<Messaging::OTAPacket>(nullptr);
}

inline void FinishOTAPacketBuffer(::flatbuffers::FlatBufferBuilder &fbb,
                                  ::flatbuffers::Offset<Messaging::OTAPacket> root) {
    fbb.Finish(root);
}

inline void FinishSizePrefixedOTAPacketBuffer(::flatbuffers::FlatBufferBuilder &fbb,
                                              ::flatbuffers::Offset<Messaging::OTAPacket> root) {
    fbb.FinishSizePrefixed(root);
}

} // namespace Messaging

#endif // FLATBUFFERS_GENERATED_OTAPACKET_MESSAGING_H_
